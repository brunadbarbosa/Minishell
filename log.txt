# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/04 17:25:19 by brmaria-          #+#    #+#              #
#    Updated: 2025/12/13 16:02:49 by brmaria-         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

###############################################################################
#                            Target and Compiler                              #
###############################################################################
NAME := minishell

CC := cc

###############################################################################
#                                    Flags                                    #
###############################################################################
FLAGS = -Wall -Wextra -Werror -g
LDFLAGS := -lreadline

###############################################################################
#                                    vpath                                    #
###############################################################################
vpath %.h includes
vpath %.c error
vpath %.c parsing
vpath %.c exec
vpath %.c builtins
vpath %.c signals

###############################################################################
#                            Libft path and archive                           #
###############################################################################
LIBFT_PATH := ./libft
LIBFT := $(LIBFT_PATH)/libft.a

###############################################################################
#                              Builds' Directory                              #
###############################################################################
BUILD_DIR := build

###############################################################################
#                               Source Files                                  #
###############################################################################

ERROR_FILES := clean_cmd.c clean_env.c clean_shell.c clean_tokens.c \
				clean_utils.c close_pipe.c

PARSE_FILES := loop.c my_exit.c input_checker.c lexer.c parser_utils.c \
				parser.c shell_init.c token_maker.c syntax.c\
				expand_tk.c test.c token_utils.c expand_tk_utils.c heredoc.c\
				
BUILTIN_FILES := cd.c echo.c env.c exit.c export.c pwd.c unset.c is_builtin.c

EXEC_FILES := startproc.c open_redirs.c ft_execute.c ft_execve.c pipe_utils.c \
				proc_utils.c parent.c

SIGNALS_FILES := signals.c

MAIN_FILES := main.c

SRC_FILES := $(ERROR_FILES) $(PARSE_FILES) $(BUILTIN_FILES) $(EXEC_FILES) $(SIGNALS_FILES) $(MAIN_FILES)

###############################################################################
#                               Object Files                                  #
###############################################################################
OBJ_FILES := $(SRC_FILES:%.c=$(BUILD_DIR)/%.o)

###############################################################################
#                                 Includes                                    #
###############################################################################
INCLUDES := minishell.h parser.h


###############################################################################
#                                Debug Flags                                  #
###############################################################################
gdb: FLAGS += -g
leak: FLAGS += -fsanitize=address,undefined -g

###############################################################################
#                                Basic Rules                                  #
###############################################################################
.PHONY: all clean fclean re valgrind norm gdb

all: $(BUILD_DIR) $(LIBFT) $(NAME)

###############################################################################
#                                   Libft                                     #
###############################################################################
$(LIBFT):
	@make --no-print-directory -C $(LIBFT_PATH)

###############################################################################
#                               Create ./build                                #
###############################################################################
$(BUILD_DIR):
	@mkdir -p $@
	@echo "$(GREEN)Creating$(RESET) $(BUILD_DIR)"
	@echo "$(GREEN)Compiled objects$(RESET)"

###############################################################################
#                        Compile objects into /build                          #
###############################################################################
$(BUILD_DIR)/%.o: %.c
	@mkdir -p $(dir $@)
	@$(CC) $(FLAGS) -c $< -o $@

###############################################################################
#                               Build executable                              #
###############################################################################
$(NAME): $(OBJ_FILES) $(LIBFT)
	@$(CC) $(FLAGS) $(OBJ_FILES) $(LIBFT) $(LDFLAGS) -o $@
	@echo "$(YELLOW)Compiled$(RESET) $(NAME)"

###############################################################################
#                                Debug Rules                                  #
###############################################################################
norm:
	@norminette -R CheckForbiddenSourceHeader

valgrind: $(NAME)
	@echo "$(YELLOW)Valgrind Report$(RESET)"
	@valgrind --leak-check=full \
	--suppressions=./.supp/readline.supp \
	--show-leak-kinds=all \
	--track-origins=yes \
	--trace-children=yes \
	--track-fds=yes \
	./$(NAME)

gdb: $(NAME)
	@gdb --tui ./$(NAME)

leak: $(NAME)
	@echo "$(YELLOW)Running with sanitizers (adress, leak, undefined)$(RESET)"
	@./$(NAME)

###############################################################################
#                                  Clean up                                   #
###############################################################################
clean:
	@rm -rf $(BUILD_DIR)
	@make --no-print-directory -C $(LIBFT_PATH) clean
	@echo "$(BLUE)Cleaned object files$(RESET)"

fclean: clean
	@rm -f $(NAME)
	@rm -rf test_log
	@echo "$(BLUE)Cleaned test_log$(RESET)"
	@rm -rf test_bonus_log
	@echo "$(BLUE)Cleaned test_bonus_log$(RESET)"
	@rm -f $(BONUS_NAME)
	@make --no-print-directory -C $(LIBFT_PATH) fclean
	@echo "$(BLUE)Cleaned executables$(RESET) $(NAME) $(BONUS_NAME)"

re: fclean all

###############################################################################
#                                    Help                                     #
###############################################################################
help:
	@echo "$(YELLOW)Available targets:$(RESET)"
	@echo "  all           - Build the mandatory executable"
	@echo "  clean         - Remove object files"
	@echo "  fclean        - Remove all built files"
	@echo "  re            - Clean and rebuild everything"
	@echo "  norm          - Run norminette checks"
	@echo "  valgrind      - Run valgrind on mandatory"
	@echo "  gdb           - Start gdb on mandatory"

###############################################################################
#                               Color Codes                                   #
###############################################################################
RED = \033[1;31m

GREEN = \033[1;32m

YELLOW = \033[1;33m

BLUE = \033[1;34m

RESET = \033[0m/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/04 17:33:55 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/11 15:01:27 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "includes/minishell.h"

//t_shell *global_shell;

int	main(int argc, char **argv, char **envp)
{
	t_shell	*shell;

	(void)argc;
	(void)argv;
	shell = NULL;
	shell = ft_init_shell(shell, envp);
	global_shell = shell;
//	print_env(&shell);
	init_interactive_mode();
	loop(shell);
	ft_clean_shell(shell, NULL);
	return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/11 13:20:40 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/11 15:07:48 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

t_shell *global_shell;

void	sig_handler(int signum)
{
	(void)signum;
	if (global_shell)
		global_shell->exit_status = 130;
	rl_replace_line("", 0);
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_redisplay();
}

void	init_interactive_mode(void)
{
	signal(SIGINT, sig_handler);
	signal(SIGQUIT, SIG_IGN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_tk.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 14:19:29 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/05 17:15:47 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	ft_removequotes(char **str);
static char	*ft_replace(char *old, t_shell *shell);
static char	*ft_newstr(char *old, t_shell *shell);

/// @brief expands the tokens when necessary
/// @param lst token list
/// @param env environment
void	ft_expand(t_token **lst, t_shell *shell)
{
	t_token	*current;
	char	*expanded;
	int		i;

	if (!lst || !shell->env)
		return ;
	i = 0;
	current = *lst;
	while (current)
	{
		if (current->type == TOKEN_WORD)
		{
			expanded = ft_replace(current->value, shell);
			free(current->value);
			current->value = expanded;
			ft_removequotes(&current->value);
		}
		current = current->next;
	}
}

static void	ft_removequotes(char **str)
{
	char	*trimmed;
	int		i;
	int		j;
	int		new_len;
	char	quote_state;

	i = 0;
	new_len = 0;
	quote_state = 0;
	if (!*str)
		return ;
	while ((*str)[i])
	{
		if ((*str)[i] != '\'' && (*str)[i] != '\"')
			new_len++;
		i++;
	}
	trimmed = malloc(sizeof(char) * (new_len + 1));
	if (!trimmed)
		return ;
	i = 0;
	j = 0;
	while ((*str)[i])
	{
		if (((*str)[i] == '\'' || (*str)[i] == '\"') && quote_state == 0)
			quote_state = (*str)[i];
		else if ((*str)[i] == quote_state)
			quote_state = 0;
		else
		{
			trimmed[j] = (*str)[i];
			j++;
		}
		i++;	
	}
	trimmed[j] = '\0';
	free(*str);
	*str = trimmed;
}

static char	*ft_replace(char *old, t_shell *shell)
{
	char	*new;

	if (!old || !shell->env)
		return (NULL);
	new = ft_newstr(old, shell);
	return (new);
}

static char	*ft_newstr(char *old, t_shell *shell)
{
	char	*new;
	size_t	new_size;

	if (!old || !shell->env)
		return (NULL);
	new_size = ft_newstrsize(old, shell->env);
	new = malloc(sizeof(char) * (new_size + 1));
	if (!new)
		return (NULL);
	new[new_size] = '\0';
	ft_makenewstr(old, shell, &new);
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_tk_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/02 19:04:51 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/05 17:23:54 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

size_t	ft_newstrsize(char *old, t_env *env)
{
	int		i;
	int		var_len;
	size_t	new_size;
	char	*expansion;

	i = 0;
	var_len = 0;
	new_size = 0;
	while (old[i])
	{
		if (old[i] == '$' && old[i + 1] && \
(old[i + 1] == '_' || ft_isalnum(old[i + 1])))
		{
			expansion = ft_findexp(&old[i + 1], &var_len, env);
			new_size += ft_strlen(expansion);
			free(expansion);
			i += var_len + 1;
		}
		else
		{
			new_size++;
			i++;
		}
	}
	return (new_size);
}

void	ft_makenewstr(char *old, t_shell *shell, char **new)
{
	int     var_len;
    char    *expansion;
    int     i;
    int     j;
    char    quote_state;

    var_len = 0;
    i = 0;
    j = 0;
    quote_state = 0;
    while (old[i])
    {
        if (old[i] == '\'' || old[i] == '"')
        {
            if (quote_state == 0)
                quote_state = old[i];
            else if (quote_state == old[i])
                quote_state = 0;
        }
        if (old[i] == '$' && quote_state != '\'') 
        {

            if (old[i + 1] == '?')
            {
                expansion = ft_itoa(shell->exit_status);
                if (expansion)
                {
                    ft_memmove(&(*new)[j], expansion, ft_strlen(expansion));
                    j += ft_strlen(expansion);
                    free(expansion);
                }
                i += 2;
                continue;
            }
            else if (old[i + 1] == '_' || ft_isalnum(old[i + 1]))
            {
                expansion = ft_findexp(&old[i + 1], &var_len, shell->env);
                if (expansion)
                {
                    ft_memmove(&(*new)[j], expansion, ft_strlen(expansion));
                    j += ft_strlen(expansion);
                    free(expansion);
                }
                i += var_len + 1;
                continue;
            }
        }
        (*new)[j++] = old[i++];
    }
    (*new)[j] = '\0';
}

char	*ft_findexp(char *var_start, int *var_len, t_env *env)
{
	t_env	*node;
	int		i;

	if (!var_start || !env)
		return (ft_strdup(""));
	*var_len = 0;
	i = 0;
	while (var_start[*var_len] && \
(ft_isalnum(var_start[*var_len]) || var_start[*var_len] == '_'))
		(*var_len)++;
	if (*var_len == 0)
		return (ft_strdup(""));
	node = env;
	while (node)
	{
		i = 0;
		while (i < *var_len && var_start[i] && \
node->name[i] && var_start[i] == node->name[i])        // 1. RASTREAMENTO DO ESTADO DAS ASPAS
			i++;
		if (i == *var_len && node->name[i] == '\0')
			return (ft_strdup(node->value));
		node = node->next;
	}
	return (ft_strdup(""));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:33:02 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/13 16:02:03 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief reads from STDIN into the heredoc file
/// @param fd the file descriptor to the heredoc file
/// @param delimiter the line defined as heredoc delimiter
void	read_into_here(int fd, char *delimiter)
{
	char	*eof;
	char	*input;

	if (fd < 0)
		return ;
	eof = ft_strjoin(delimiter, "\n");
	while (1)
	{
		ft_putstr_fd("here_doc> ", 1);
		input = get_next_line(STDIN_FILENO);
		if (((ft_strncmp(eof, input, ft_strlen(input))) == 0) || !input)
			break ;
		ft_putstr_fd(input, fd);
		free(input);
	}
	free(eof);
	if (input)
		free(input);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   input_checker.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/04 15:20:13 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/15 17:08:01 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

bool	ft_isspace(const char c)
{
	return ((c > 8 && c < 14) || c == 32);
}

bool	is_operator(const char *str)
{
	if (!str)
		return (false);
	else if (ft_strncmp(str, "<<", 2) == 0)
		return (true);
	else if (ft_strncmp(str, ">>", 2) == 0)
		return (true);
	else if (*str == '>' || *str == '<' || *str == '|' || *str == ' ')
		return (true);
	else
		return (false);
}

bool	is_quote(const char str)
{
	if (!str)
		return (false);
	else if (str == '"' || str == '\'')
		return (true);
	else
		return (false);
}

bool	is_delimiter(const char *str)
{
	if (!str)
		return (false);
	else if (is_operator(str) || ft_isspace(*str))
		return (true);
	else
		return (false);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 19:06:57 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/11 17:44:14 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	ft_add_token(t_token **lst, t_token *new);
static void	ft_rmempty(t_token **tokens);
static int	ft_isemptytoken(t_token *token);
static void	ft_removenode(t_token **tokens, t_token **curr, t_token *prev);

/// @brief tokenizes the input
/// @param input line from the user
void	ft_lexer(t_shell *shell, char *input)
{
	t_token	*token_node;
	ssize_t	size;
	int		i;

	if (!input)
		return ;
	i = 0;
	while (input[i])
	{
		while (ft_isspace(input[i]))
			i++;
		size = ft_tokensize(&input[i]);
		if (size == -1)
			return (ft_putstr_fd("Unclosed quotes\n", 2));
		token_node = ft_new_token(&input[i], size);
		if (!token_node)
			return (ft_clean_shell(shell, "Failed to allocate token\n"));
		ft_add_token(&shell->tokens, token_node);
		i += size;
	}
	ft_expand(&shell->tokens, shell);
	ft_rmempty(&shell->tokens);
}

/// @brief adds newly generated token nodes to the token list
/// @param lst the head of the token list
/// @param new the new token to be added to the list
static void	ft_add_token(t_token **lst, t_token *new)
{
	t_token	*current;

	if (!new)
		return ;
	if (!*lst)
	{
		*lst = new;
		return ;
	}
	current = *lst;
	while (current->next)
		current = current->next;
	current->next = new;
}

/// @brief removes tokens with empty value
static void	ft_rmempty(t_token **tokens)
{
	t_token	*curr;
	t_token	*prev;

	if (!tokens || !*tokens)
		return ;
	curr = *tokens;
	prev = NULL;
	while (curr)
	{
		if (ft_isemptytoken(curr))
			ft_removenode(tokens, &curr, prev);
		else
		{
			prev = curr;
			curr = curr->next;
		}
	}
}

static int	ft_isemptytoken(t_token *token)
{
    // se não for WORD, pode remover normalmente
    if (token->type != TOKEN_WORD)
    {
        int i = 0;
        while (token->value[i] && ft_isspace(token->value[i]))
            i++;
        return (token->value[i] == '\0');
    }

    // se for WORD e está vazio, NÃO remover!
    return 0;
}

static void	ft_removenode(t_token **tokens, t_token **curr, t_token *prev)
{
	t_token	*next;

	next = (*curr)->next;
	if (prev == NULL)
		*tokens = next;
	else
		prev->next = next;
	free((*curr)->value);
	free(*curr);
	*curr = next;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   loop.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/04 17:27:26 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/13 15:59:07 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "../includes/minishell.h"

//int	wrong_fds(t_shell *shell);
int  ft_redcmd(int type, int fd);
int	get_redir(t_redir *red, t_shell *shell);

int	ft_have_something(char *line)
{
	int	i;

	i = 0;
	while (line[i] && (line[i] == 32 || line[i] == '\t'))
		i++;
	if (line[i])
		return (1);
	return (0);
}

/// @brief the shell loop. Goes on purposeful exit from user
/// @param shell the master struct
void	loop(t_shell *shell)
{
	char	*input;

	if (!shell)
		return ;
	while (true)
	{
		input = readline("minishell> ");
		if (!input)
		{
			ft_putendl_fd("exit", STDOUT_FILENO);
			break ;
		}
		if (!input[0] || !ft_have_something(input) || !strcmp(input, "$EMPTY"))
			continue ;
		if (!ft_strncmp(input, "$EMPTY", 6))
			input += 6;
		add_history(input);
		ft_lexer(shell, input);
		ft_syntax(shell);
		ft_parser(shell);
		//nft_printcmd(shell);
		ft_openredirs(shell->cmds, shell);
		parent(shell);
		if (!ft_strncmp(input - 6, "$EMPTY", 6))
			input -= 6;
		free(input);
		ft_clean_tokens(&shell->tokens, NULL);
		ft_clean_cmd_lst(&shell->cmds, NULL);
	}
}



// int	wrong_fds(t_shell *shell)
// {
// 	t_redir *redirs;

// 	redirs = shell->cmds->redirs;
// 	while(redirs)
// 	{
// 		if (get_redir(redirs, shell))
// 		{
// 			ft_redcmd(redirs->type, -1);

// 			return (1);
// 		}
// 		redirs = redirs->next;
// 	}
// 	return (0);
// }
// /* ************************************************************************** */
// /*                                                                            */
// /*                                                        :::      ::::::::   */
// /*   exit.c                                             :+:      :+:    :+:   */
// /*                                                    +:+ +:+         +:+     */
// /*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
// /*                                                +#+#+#+#+#+   +#+           */
// /*   Created: 2025/11/18 19:07:07 by adpinhei          #+#    #+#             */
// /*   Updated: 2025/11/18 20:07:49 by adpinhei         ###   ########.fr       */
// /*                                                                            */
// /* ************************************************************************** */

#include "../includes/minishell.h"

void	my_exit(t_shell *shell, char *input)
{
	size_t	len;

	len = ft_strlen(input);
	if (len == 0)
		return ;
	if (!ft_strncmp(input, "exit", 5))
	{
		free(input);
		ft_clean_shell(shell, NULL);
		exit(EXIT_SUCCESS);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 16:26:33 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/20 16:45:21 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static t_cmd	*build_cmd_list(t_token *tokens);
static void		buildredir(t_cmd *cmd, t_token *tk);
static void		buildcmd(t_cmd *cmd, t_token *tk);
static char		**buildargs(char **args, char *str);

/// @brief generates the command list from the token list
void	ft_parser(t_shell *shell)
{
	if (!shell || !shell->tokens)
		return ;
	shell->cmds = build_cmd_list(shell->tokens);
}

static t_cmd	*build_cmd_list(t_token *tokens)
{
	t_token	*tk;
	t_cmd	*head;
	t_cmd	*current;

	if (ft_initcmdlist(&tk, tokens, &head, &current))
		return (NULL);
	while (tk)
	{
		if (tk->type > 1 && tk->type < 6)
		{
			buildredir(current, tk);
			tk = tk->next;
		}
		else if (tk->type == TOKEN_WORD)
			buildcmd(current, tk);
		else if (tk->type == TOKEN_PIPE)
		{
			if (ft_buildnextcmd(&current, head))
				return (NULL);
		}
		if (!tk->next)
			break ;
		tk = tk->next;
	}
	return (head);
}

static void	buildredir(t_cmd *cmd, t_token *tk)
{
	t_redir	*redir;
	t_redir	*tmp;

	if (!cmd || !tk || !tk->next)
		return ;
	redir = malloc(sizeof(t_redir));
	if (!redir)
		return ;
	ft_initredir(redir, tk);
	if (!redir->file)
	{
		free(redir);
		return ;
	}
	if (!cmd->redirs)
		cmd->redirs = redir;
	else
	{
		tmp = cmd->redirs;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = redir;
	}
}

static void	buildcmd(t_cmd *cmd, t_token *tk)
{
	if (!cmd || !tk)
		return ;
	if (!cmd->cmd)
	{
		cmd->cmd = ft_strdup(tk->value);
		cmd->args = malloc(sizeof(char *) * 2);
		if (!cmd->args)
			return ;
		cmd->args[0] = ft_strdup(tk->value);
		cmd->args[1] = NULL;
	}
	else
		cmd->args = buildargs(cmd->args, tk->value);
}

static char	**buildargs(char **args, char *str)
{
	char	**new_args;
	int		i;

	i = 0;
	while (args[i])
		i++;
	new_args = malloc(sizeof(char *) * (i + 2));
	if (!new_args)
		return (args);
	i = 0;
	while (args[i])
	{
		new_args[i] = args[i];
		i++;
	}
	new_args[i] = ft_strdup(str);
	new_args[i + 1] = NULL;
	free(args);
	return (new_args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 18:42:08 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/20 16:47:45 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

t_redir_type	redirtype(t_token_type type)
{
	if (type == TOKEN_APPEND)
		return (REDIR_APPEND);
	if (type == TOKEN_HEREDOC)
		return (REDIR_HERE);
	if (type == TOKEN_RED_IN)
		return (REDIR_IN);
	if (type == TOKEN_RED_OUT)
		return (REDIR_OUT);
	else
		return (-1);
}

void	ft_initredir(t_redir *redir, t_token *tk)
{
	if (!redir || !tk)
		return ;
	redir->file = ft_strdup(tk->next->value);
	redir->fd = -1;
	redir->type = redirtype(tk->type);
	redir->next = NULL;
}

int	ft_buildnextcmd(t_cmd **current, t_cmd *head)
{
	(*current)->next = ft_calloc(1, sizeof(t_cmd));
	if (!(*current)->next)
	{
		ft_clean_cmd_lst(&head, "Unable to allocate t_cmd\n");
		return (1);
	}
	(*current) = (*current)->next;
	return (0);
}

int	ft_initcmdlist(t_token **tk, t_token *tks, t_cmd **h, t_cmd **c)
{
	*h = ft_calloc(1, sizeof(t_cmd));
	if (!*h)
		return (1);
	*c = *h;
	*tk = tks;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_init.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/04 17:27:45 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/11 15:00:33 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static t_env	*ft_create_env(char **envp);
static t_env	*new_env_node(char *entry);
static void		env_add_back(t_env **env, t_env *new);
static void		ft_shlvl(t_env *env);

/// @brief initialize the super struct t_shell
/// @param shell the super struct
/// @param envp the pointer to the environment variables
t_shell	*ft_init_shell(t_shell *shell, char **envp)
{
	shell = malloc(sizeof(t_shell));
	if (!shell)
		return (NULL) ;
	if (!envp)
	{
		ft_putstr_fd("No environment\n", 2);
		return (NULL);
	}
	shell->std_in = STDIN_FILENO;
	shell->std_out = STDOUT_FILENO;
	shell->cmds = NULL;
	shell->tokens = NULL;
	shell->exit_status = 0;
	shell->env = ft_create_env(envp);
	ft_shlvl(shell->env);
	return (shell);
}

static t_env	*ft_create_env(char **envp)
{
	t_env	*env;
	t_env	*node;
	int		i;

	if (!envp || !envp[0])
		return (NULL);
	env = NULL;
	i = 0;
	while (envp[i])
	{
		node = new_env_node(envp[i]);
		if (!node)
			return (NULL);
		env_add_back(&env, node);
		i++;
	}
	return (env);
}

static t_env	*new_env_node(char *entry)
{
	t_env	*node;
	int		j;

	node = malloc(sizeof(t_env));
	if (!node)
		return (NULL);
	j = 0;
	while (entry[j] && entry[j] != '=')
		j++;
	node->name = malloc(sizeof(char) * (j + 1));
	if (!node->name)
		return (NULL);
	ft_strlcpy(node->name, entry, j + 1);
	if (entry[j] == '=')
		node->value = ft_strdup(entry + j + 1);
	else
		node->value = ft_strdup("");
	if (!node->value)
		return (NULL);
	node->next = NULL;
	return (node);
}

static void	env_add_back(t_env **env, t_env *new)
{
	t_env	*temp;

	if (!*env)
	{
		*env = new;
		return ;
	}
	temp = *env;
	while (temp->next)
		temp = temp->next;
	temp->next = new;
}

static void	ft_shlvl(t_env *env)
{
	t_env	*current;
	int		tmp;

	if (!env)
		return ;
	current = env;
	while (current)
	{
		if (!ft_strncmp(current->name, "SHLVL", 5))
		{
			tmp = ft_atoi(current->value);
			free(current->value);
			current->value = ft_itoa(tmp + 1);
			return ;
		}
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   syntax.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 20:40:24 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/24 15:10:02 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_syntax(t_shell *shell)
{
	t_token	*tk;

	if (!shell || !shell->tokens)
		return ;
	tk = shell->tokens;
	if (tk->type == TOKEN_PIPE)
	{
		ft_clean_tokens(&shell->tokens, "Invalid syntax\n");
		return ;
	}
	while (tk)
	{
		if (tk->type > TOKEN_WORD)
		{
			if (!tk->next || tk->next->type != TOKEN_WORD)
				return (ft_clean_tokens(&shell->tokens, "Invalid syntax\n"));
		}
		if (tk->type != TOKEN_WORD && !tk->next)
			return (ft_clean_tokens(&shell->tokens, "Invalid syntax\n"));
		tk = tk->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 19:10:51 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/18 21:11:30 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_printlst(t_shell *shell)
{
	int	i = 1;
	if (!shell)
		return ;
	t_token *current = shell->tokens;
	while (current)
	{
		ft_printf("TOKEN #%i\n [value: %s]\n [type: %i]\n***\n",i, current->value, current->type);
		i++;
		current = current->next;
	}
}

void	print_env(t_shell *shell)
{
	if (!shell)
	{
		ft_printf("No shell\n");
		return ;
	}
	t_env	*env = shell->env;
	while(env->next)
	{
		ft_printf("[var name] %s\n", env->name);
		ft_printf("\t[value] %s\n", env->value);
		env = env->next;
	}
	ft_printf("[var name] %s\n", env->name);
	ft_printf("\t[value] %s\n", env->value);
}

void	ft_printcmd(t_shell *shell)
{
	if (!shell)
		return ;
	t_cmd	*current = shell->cmds;
	while (current)
	{
		ft_printf("[cmd name] %s\n", current->cmd);
		if (current->args)
		{
			int	j = 0;
			while (current->args[j])
			{
				ft_printf("\t\t[args] %s\n", current->args[j]);
				j++;
			}
		}
		if (current->redirs)
		{
			t_redir	*tmp = current->redirs;
			while (tmp)
			{
				ft_printf("\t\t[redir type] %i\n", tmp->type);
				ft_printf("\t\t[redir file] %s\n", tmp->file);
				tmp = tmp->next;;
			}
		}
		if (current->next)
			ft_printf("\t\t[pipes to] %s\n", current->next->cmd);
		ft_printf("\n\n");
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_maker.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/05 09:20:16 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/20 15:43:27 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief copies from the input to a new_token node
/// @param input the string from the user
/// @param size the size of the token returned by ft_tokensize()
/// @return the new token
t_token	*ft_new_token(char *input, ssize_t size)
{
	t_token	*token;

	if (!input || size == -1)
		return (NULL);
	token = ft_init_token(size);
	if (!token)
		return (NULL);
	ft_strlcpy(token->value, input, (size_t)size + 1);
	if (!token->value)
	{
		free(token);
		return (NULL);
	}
	ft_settokentype(token);
	return (token);
}

/// @brief determine the token type
/// @param token the newly created token node
void	ft_settokentype(t_token *token)
{
	char	*value;

	if (!token)
		return ;
	value = token->value;
	if (!ft_strncmp(value, "<<", 2))
		token->type = TOKEN_HEREDOC;
	else if (!ft_strncmp(value, ">>", 2))
		token->type = TOKEN_APPEND;
	else if (!ft_strncmp(value, "<", 1))
		token->type = TOKEN_RED_IN;
	else if (!ft_strncmp(value, ">", 1))
		token->type = TOKEN_RED_OUT;
	else if (!ft_strncmp(value, "|", 1))
		token->type = TOKEN_PIPE;
	else
		token->type = TOKEN_WORD;
}

/// @brief initializes token nodes
/// @param size the size of the string to be allocated as token->value
/// @return the initialized token
t_token	*ft_init_token(ssize_t size)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->value = malloc(sizeof(char) * (size + 1));
	if (!token->value)
	{
		free(token);
		return (NULL);
	}
	token->type = -1;
	token->next = NULL;
	return (token);
}

/// @brief finds the size of the next token
/// @param input the current position in the input
/// @return the size of the token, or -1 if the quotes are open
ssize_t	ft_tokensize(char *input)
{
	int		i;
	char	quotes;

	if (!input)
		return (0);
	i = 0;
	quotes = 0;
	if (is_operator(&input[i]))
		return (ft_operatorsize(&input[i]));
	while (input[i])
	{
		if (is_quote(input[i]) && !quotes)
			quotes = input[i++];
		while (quotes && input[i])
		{
			if (input[i] == quotes)
				quotes = 0;
			i++;
		}
		if (!quotes && is_delimiter(&input[i]) && input[i])
			break ;
		if (input[i])
			i++;
	}
	return (ft_openquotes(i, quotes));
}

ssize_t	ft_operatorsize(char *input)
{
	int	i;

	i = 0;
	if (!input)
		return (0);
	if (input[i] == '|')
		return (1);
	if (input[i] == '>')
	{
		if (input[i + 1] == '>')
			return (2);
		else
			return (1);
	}
	if (input[i] == '<')
	{
		if (input[i + 1] == '<')
			return (2);
		else
			return (1);
	}
	else
		return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 15:43:03 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/20 15:43:29 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	ft_openquotes(int i, int quotes)
{
	if (quotes)
		return (quotes);
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 18:54:41 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/13 16:18:41 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/libft.h"
#include <signal.h>
# include <stdio.h>
# include <unistd.h>
# include <stdarg.h>
# include <stdlib.h>
# include <strings.h>
# include <fcntl.h>
# include <errno.h>
# include <sys/wait.h>
# include <readline/readline.h>
# include <readline/history.h>
# include <stdbool.h>
# include "structs.h"

/*****************************************************************************/
/*                                Global Variable                            */
/*****************************************************************************/

extern  t_shell *global_shell;

/*****************************************************************************/
/*                                Parsing Functions                          */
/*****************************************************************************/

void			loop(t_shell *shell);
t_shell			*ft_init_shell(t_shell *shell, char **envp);
void			my_exit(t_shell *shell, char *input);
void			ft_parser(t_shell *shell);
void			ft_lexer(t_shell *shell, char *input);
void			ft_settokentype(t_token *token);
void			ft_expand(t_token **lst, t_shell *shell);
void			ft_syntax(t_shell *shell);
void			ft_initredir(t_redir *redir, t_token *tk);
void			ft_makenewstr(char *old, t_shell *shell, char **new);

char			*ft_findexp(char *var_start, int *var_len, t_env *env);

t_token			*ft_new_token(char *input, ssize_t size);
t_token			*ft_init_token(ssize_t size);

ssize_t			ft_tokensize(char *input);
ssize_t			ft_operatorsize(char *input);
size_t			ft_newstrsize(char *old, t_env *env);

bool			ft_isspace(const char c);
bool			is_operator(const char *str);
bool			is_quote(const char str);
bool			is_delimiter(const char *str);

int				ft_openquotes(int i, int quotes);
int				ft_buildnextcmd(t_cmd **current, t_cmd *head);
int				ft_initcmdlist(t_token **tk, t_token *tks, t_cmd **h,\
				t_cmd **c);

t_redir_type	redirtype(t_token_type type);

/*testing functions*/

void			ft_printlst(t_shell *shell);
void			print_env(t_shell *shell);
void			ft_printcmd(t_shell *shell);
void			read_into_here(int fd, char *delimiter);

/*****************************************************************************/
/*                                  Builtin Functions                        */
/*****************************************************************************/

void	change_env(char *old_pwd, char *new_pwd, t_shell *shell);
char	*get_bigger_buffer(char *prev, int prev_len, int new_prev_len);
char	*copy_from_env(char **args, t_shell *shell);
char	*get_current_path(void);
void	ft_cd(t_shell *shell);

void	ft_echo(char **args, t_shell *shell);

void	ft_env(t_env *env);

int		safe_atoll(const char *str, long long *out);
void	ft_exit(char **args, char *cmd, t_shell *shell);

t_env	*create_env_node(const char *env_str);
int		check_args(char *args);
t_env	*get_value(t_env *env, char *name);
void 	set_value(char *str, t_env **env);
void	ft_export(char **args, t_shell *shell);

void	execute_builtin(t_cmd *cmd, t_shell *shell);
int		ft_is_parent_builtin(t_cmd *cmd);

char 	*getpwd(t_env *env);
void	ft_pwd(t_env *env);

void	remove_env(t_env **env, char *name);
void	ft_unset(char **args, t_shell *shell);

/*****************************************************************************/
/*                                  Exec Functions                           */
/*****************************************************************************/

void			ft_startproc(t_shell *shell);
void			ft_openredirs(t_cmd *cmdlst, t_shell *shell);
void			ft_execute(t_cmd *cmd, t_env *env, t_shell *shell);
void			ft_execve(char **arg, char **envp, t_shell *shell);
void			ft_freepipe_st(t_pipe *pipe_st);
void			ft_fork(t_cmd *lst, t_pipe *pipe_st, t_shell *shell);
void			parent(t_shell *shell);

//int				ft_pipe(t_cmd *cmdlst);
int				init_pipe(t_pipe *pipe, t_cmd *cmds);
int				is_builtin(t_cmd *cmd);

/******************************************************************************/
/*                                Signal Functions                            */
/******************************************************************************/

void	init_interactive_mode(void);
void	sig_handler(int signum);

/******************************************************************************/
/*                                Cleaning Functions                          */
/******************************************************************************/

void			ft_clean_shell(t_shell *shell, char *msg);
void			ft_clean_cmd_lst(t_cmd **lst, char *msg);
void			ft_clean_env(t_env **env, char *msg);
void			ft_clean_tokens(t_token **lst, char *msg);
void			ft_clean_redirs(t_redir **redirs);
void			ft_free_args(char **args);
void			ft_closepipe(int fd1, int fd2, char *str);



int	get_redir(t_redir *red, t_shell *shell);
int  ft_redcmd(int type, int fd);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   structs.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/23 17:29:06 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/06 19:42:15 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef STRUCTS_H
# define STRUCTS_H

# include "minishell.h"

typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_PIPE,
	TOKEN_RED_IN,
	TOKEN_RED_OUT,
	TOKEN_APPEND,
	TOKEN_HEREDOC,
}	t_token_type;

typedef enum e_redir_type
{
	REDIR_IN,
	REDIR_OUT,
	REDIR_APPEND,
	REDIR_HERE
}	t_redir_type;

/// @brief to be used in execution phase to deal with fd redirections
typedef struct s_pipe
{
	pid_t	*pids;
	int		pid_count;
	int		pipefd[2];
	int		prev_read_fd;
	char	**heredocs;
}	t_pipe;

typedef struct s_token
{
	t_token_type	type;
	char			*value;
	struct s_token	*next;
}	t_token;

/// @brief these structs will form our environment.
typedef struct s_env
{
	char			*name;
	char			*value;
	struct s_env	*next;
}	t_env;

/// @brief redirection details. t_cmd will have a pointer to this.
typedef struct s_redir
{
	t_redir_type	type;
	char			*file;
	int				fd;
	struct s_redir	*next;
}	t_redir;

/// @brief main struct to be passed for execution
typedef struct s_cmd
{
	char			*cmd;
	char			**args;
	t_redir			*redirs;
	struct s_cmd	*next;
}	t_cmd;

typedef struct s_shell
{
	int		std_in;
	int		std_out;
	t_env	*env;
	t_token	*tokens;
	t_cmd	*cmds;
	char	**heredoc;
	int		exit_status;
}	t_shell;

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_execute.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/24 18:20:08 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/13 16:06:18 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static char	**ft_envstr(t_env *lst);
static char	*get_envp(t_env *env);
static int	ft_envsize(t_env *lst);

/// @brief passes the command to execve
/// @param cmd the command to be executed
/// @param env environment to be turned into char** and then passed
/// @param shell the main struct
void	ft_execute(t_cmd *cmd, t_env *env, t_shell *shell)
{
	char	**envp;

	if (!cmd || !shell)
		return ;
	if (is_builtin(cmd))
	{
		execute_builtin(cmd, shell);
		exit(shell->exit_status);
	}
	else
	{
		envp = ft_envstr(env);
		if (!envp)
			return ;
		ft_execve(cmd->args, envp, shell);
		ft_free_args(envp);
	}
}

/// @brief turns t_env *env into char **envstr
/// @return the char** that holds the environment
static char	**ft_envstr(t_env *lst)
{
	char	**envstr;
	t_env	*env;
	int		i;

	if (!lst)
		return (NULL);
	i = 0;
	envstr = malloc(sizeof(char *) * (ft_envsize(lst) + 1));
	if (!envstr)
		return (NULL);
	i = 0;
	env = lst;
	while (env)
	{
		envstr[i] = get_envp(env);
		if (!envstr[i])
		{
			ft_free_args(envstr);
			return (NULL);
		}
		i++;
		env = env->next;
	}
	envstr[i] = NULL;
	return (envstr);
}

/// @brief concatenates env->name + '=' + env->value
/// @param env the t_env node
/// @return the string with a variable in envp format
static char	*get_envp(t_env *env)
{
	char	*res;
	char	*tmp;

	if (!env)
		return (NULL);
	res = ft_strdup(env->name);
	tmp = ft_strjoin(res, "=");
	free(res);
	res = tmp;
	tmp = NULL;
	tmp = ft_strjoin(res, env->value);
	free(res);
	res = tmp;
	tmp = NULL;
	return (res);
}

static int	ft_envsize(t_env *lst)
{
	int	len;

	if (!lst)
		return (0);
	len = 0;
	while (lst != NULL)
	{
		len++;
		lst = lst->next;
	}
	return (len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_execve.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/25 10:51:11 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/11 18:08:41 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static char	*ft_path(char *cmd, char **envp);
static void	ft_free(char **str);
static char	*ft_str2join(char *path, char *str1, char *str2);

/// @brief calls execve
/// @param cmd the arguments contained in t_cmd->args
/// @param envp the environment parsed into char**
void	ft_execve(char **cmd, char **envp, t_shell *shell)
{
	char	*path;

	if (!cmd || !*cmd || !envp || !*envp)
		return ;
	if (!cmd[0][0] || cmd[0][0] == '/' || (cmd [0][0] == '.' && cmd[0][1] == '/'))
	{
		if (access(cmd[0], F_OK | X_OK))
		{
			ft_putstr_fd(": command not found\n", 2);
			return ;
		}
		path = cmd[0];
	}
	else
		path = ft_path(cmd[0], envp);
	if (!path)
	{
		ft_putstr_fd(cmd[0], 2);
		ft_putendl_fd(": command not found", 2);
		if (path)
			free(path);
		shell->exit_status = 127;
		exit(127);
	}
	execve(path, cmd, envp);
	free(path);
	path = NULL;
}

/// @brief finds the path to the command
/// @return a str containing the actual path for execve to execute or NULL
static char	*ft_path(char *cmd, char **envp)
{
	char	**path;
	char	*path_cmd;
	int		i;

	i = 0;
	while (envp[i] && ft_strncmp(envp[i], "PATH=", 5))
		i++;
	if (envp[i] == NULL)
		return (ft_putstr_fd("PATH not found\n", 2), NULL);
	path = ft_split(envp[i] + 5, ':');
	if (!path)
		return (NULL);
	i = 0;
	while (path[i++])
	{
		path_cmd = ft_str2join(path[i], "/", cmd);
		if (!path_cmd)
			return (ft_free(path), NULL);
		if (access(path_cmd, F_OK | X_OK) == 0)
			return (ft_free(path), path_cmd);
		free(path_cmd);
	}
	ft_free(path);
	return (NULL);
}

/// @brief helper function to free a char**
/// @param str 
static void	ft_free(char **str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return ;
	while (str[i])
	{
		free(str[i]);
		str[i] = NULL;
		i++;
	}
	free(str);
	str = NULL;
}

/// @brief calls ft_strjoin twice, concatenating three strings
/// @return the triple concatenated str or NULL
static char	*ft_str2join(char *path, char *str1, char *str2)
{
	char	*temp;
	char	*dest;

	if (!path || !str1 || !str2)
		return (NULL);
	temp = ft_strjoin(path, str1);
	if (!temp)
		return (NULL);
	dest = ft_strjoin(temp, str2);
	if (!dest)
	{
		free(temp);
		temp = NULL;
		return (NULL);
	}
	free(temp);
	temp = NULL;
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   open_redirs.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/24 15:52:20 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/13 16:18:11 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	get_redir(t_redir *red, t_shell *shell);
static char	*gen_filename(void);

void	ft_openredirs(t_cmd *cmdlst, t_shell *shell)
{
	t_cmd	*cmd;
	t_redir	*red;

	if (!cmdlst)
		return ;
	cmd = cmdlst;
	while (cmd)
	{
		red = cmd->redirs;
		if (red)
		{
			while (red)
			{
				if (get_redir(red, shell))
					return ;
				red = red->next;
			}
		}
		cmd = cmd->next;
	}
	return ;
}

int	get_redir(t_redir *red, t_shell *shell)
{
	char	*filename;
	
	(void)shell;
	if (red->type == REDIR_APPEND)
		red->fd = open(red->file, O_RDWR | O_CREAT | O_APPEND, 0644);
	else if (red->type == REDIR_IN)
		red->fd = open(red->file, O_RDONLY, 0644);
	else if (red->type == REDIR_OUT)
		red->fd = open(red->file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (red->type == REDIR_HERE)
	{
		filename = gen_filename();
		red->fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		if (red->fd < 0)
		{
			free(filename);
			return (1);
		}
		read_into_here(red->fd, red->file);
		close(red->fd);
		red->fd = open(filename, O_RDONLY);
		unlink(filename);
		free(filename);
	}
	if (red->fd < 0)
	{
		shell->exit_status = 1;
		return (1);
	}
	return (0);
}

/// @brief generates a random filename based on /dev/urandom
/// @return the filename
static char	*gen_filename(void)
{
	static int	i = 0;
	char		*num;
	char		*name;

	num = ft_itoa(i++);
	name = ft_strjoin(".tmp_heredoc_", num);
	free(num);
	return (name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parent.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/09 17:34:43 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/09 17:58:07 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static int	is_pipe(t_token *head);

/// @brief calls the builtins in the parent process if there are no pipes
void	parent(t_shell *shell)
{
	int	i;

	if (!shell)
		return ;
	i = is_pipe(shell->tokens);
	if (i < 0)
		return ;
	else if (i > 0)
		ft_startproc(shell);
	else
	{
		if (is_builtin(shell->cmds) && !shell->cmds->next)
			execute_builtin(shell->cmds, shell);
		else
			ft_startproc(shell);
	}
}

/// @brief checks if there is a pipe in the command line
/// @return -1 on failure, 0 if there is no pipe, 1 if there is a pipe
static int	is_pipe(t_token *head)
{
	t_token	*node;

	if (!head)
		return (-1);
	node = head;
	while (node)
	{
		if (node->type == TOKEN_PIPE)
			return (1);
		node = node->next;
	}
	return (0);
}

int	is_builtin(t_cmd *cmd)
{
	if (!cmd)
		return (0);
	if (!ft_strncmp("echo", cmd->cmd, 5))
		return (1);
	if (!ft_strncmp("cd", cmd->cmd, 3))
		return (1);
	if (!ft_strncmp("pwd", cmd->cmd, 4))
		return (1);
	if (!ft_strncmp("export", cmd->cmd, 7))
		return (1);
	if (!ft_strncmp("unset", cmd->cmd, 6))
		return (1);
	if (!ft_strncmp("env", cmd->cmd, 4))
		return (1);
	if (!ft_strncmp("exit", cmd->cmd, 5))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/28 17:44:30 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/28 18:00:23 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	ft_node_and_here(t_cmd *cmds, int *nd_cnt, int *hr_cnt);

/// @brief initializes the t_pipe struct
/// @param pipe the pipe struct to be initialized
/// @param cmds the list of commands from t_shell
/// @return 0 on sucess, greater on failure
int	init_pipe(t_pipe *pipe, t_cmd *cmds)
{
	int		node_counter;
	int		here_counter;
	int		i;

	pipe->pid_count = 0;
	pipe->prev_read_fd = -1;
	node_counter = 0;
	here_counter = 0;
	ft_node_and_here(cmds, &node_counter, &here_counter);
	pipe->pids = malloc(sizeof(pid_t) * node_counter);
	if (!pipe->pids)
		return (1);
	pipe->heredocs = malloc(sizeof(char *) * (here_counter + 1));
	if (!pipe->heredocs)
		return (free(pipe->pids), 2);
	i = 0;
	while (i <= here_counter)
		pipe->heredocs[i++] = NULL;
	return (0);
}

/// @brief counts the number of nodes and here_docs.
/// @param cmds the t_cmd list
/// @param nd_cnt node counter
/// @param hr_cnt here counter
static void	ft_node_and_here(t_cmd *cmds, int *nd_cnt, int *hr_cnt)
{
	t_cmd	*node;

	if (!cmds)
		return ;
	node = cmds;
	while (node)
	{
		*nd_cnt += 1;
		if (node->redirs && node->redirs->type == REDIR_HERE)
			*hr_cnt += 1;
		node = node->next;
	}
}

/// @brief frees the t_pipe struct after the pipe execution
/// @param pipe_st the struct allocated at ft_startproc
void	ft_freepipe_st(t_pipe *pipe_st)
{
	int	i;

	if (!pipe_st)
		return ;
	free(pipe_st->pids);
	i = 0;
	while (pipe_st->heredocs[i])
	{
		free(pipe_st->heredocs[i]);
		i++;
	}
	free(pipe_st->heredocs);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/28 18:08:56 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/11 18:07:20 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void ft_child(t_pipe *pipe_st, t_cmd *cmd, t_shell *shell);
static int  ft_dup2close(int pipefd, int stdfd);

/// @brief forks parent and child processes
/// @param lst the command list
/// @param pipe_st the struct with pipe information
/// @param shell the master struct
void    ft_fork(t_cmd *lst, t_pipe *pipe_st, t_shell *shell)
{
    t_cmd   *cmd;

    if (!lst || !pipe_st)
        return ;
    cmd = lst;
    while (cmd)
    {
        if (cmd->next && (pipe(pipe_st->pipefd) == -1))
            return (ft_freepipe_st(pipe_st));
        pipe_st->pids[pipe_st->pid_count] = fork();
        if (pipe_st->pids[pipe_st->pid_count] == -1)
            return (ft_freepipe_st(pipe_st));
        if (pipe_st->pids[pipe_st->pid_count] == 0)
        {
			signal(SIGINT, SIG_DFL);
            signal(SIGQUIT, SIG_DFL);
            ft_child(pipe_st, cmd, shell);
        }
        if (cmd->next)
        {
            close(pipe_st->pipefd[1]);
            pipe_st->prev_read_fd = pipe_st->pipefd[0];
        }
        pipe_st->pid_count++;
        cmd = cmd->next;
    }
}


/// @brief Structures the pipes in the child process and call ft_execute
/// @param pipe_st the pipe struct
/// @param cmd the command node
/// @param shell the master struct
static void	ft_child(t_pipe *pipe_st, t_cmd *cmd, t_shell *shell)
{
	t_redir	*redir;

	if (!pipe_st || !cmd || !shell)
		exit(1);
	if (pipe_st->prev_read_fd != -1)
	{
		if (ft_dup2close(pipe_st->prev_read_fd, STDIN_FILENO))
		{
			ft_freepipe_st(pipe_st);
			ft_clean_shell(shell, NULL);
			exit(1);
		}
	}
	if (cmd->next)
	{
		close(pipe_st->pipefd[0]);
		if (ft_dup2close(pipe_st->pipefd[1], STDOUT_FILENO))
		{
			ft_freepipe_st(pipe_st);
			ft_clean_shell(shell, NULL);
			exit(1);
		}
	}
	redir = cmd->redirs;
	while (redir)
	{
		if (ft_redcmd(redir->type, redir->fd))
		{
			ft_freepipe_st(pipe_st);
			ft_clean_shell(shell, NULL);
			exit(1);
		}
		redir = redir->next;
	}
	ft_freepipe_st(pipe_st);
	if (is_builtin(cmd))
	{
		execute_builtin(cmd, shell);
		ft_clean_shell(shell, NULL);
		exit(shell->exit_status);
	}
	ft_execute(cmd, shell->env, shell);
	ft_clean_shell(shell, NULL);
	exit(127);
}

/// @brief redirects command to its infile and outfile
/// @param type the redirection type
/// @param fd the file descriptor of the redirection file
/// @return 0 on success, greater then 0 on failure
int  ft_redcmd(int type, int fd)
{
    if (type == REDIR_IN || type == REDIR_HERE)
    {
        if ((dup2(fd, STDIN_FILENO)) == -1)
        {
            close(fd);
            ft_putstr_fd(" No such file or directory\n", 2);
            return (1);
        }
        close(fd);
    }
    else if (type == REDIR_OUT || type == REDIR_APPEND)
    {
        if ((dup2(fd, STDOUT_FILENO)) == -1)
        {
            close(fd);
            ft_putstr_fd(" Permission denied\n", 2);
            return (2);
        }
        close(fd);
    }
    return (0);
}

/// @brief calls dup2 and closes the pipe end
/// @param pipefd the end to be duplicated and then closed
/// @param stdfd STD_FILENO
/// @return 0 on success, greater on error
static int  ft_dup2close(int pipefd, int stdfd)
{
    int i;

    i = dup2(pipefd, stdfd);
    if (i == -1)
        return (1);
    close(pipefd);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   startproc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 17:47:40 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/13 15:55:58 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void		ft_wait(t_pipe *pipe, t_shell *shell);

/// @brief starts the processes and waits on them
void	ft_startproc(t_shell *shell)
{
	t_pipe	pipe_st;

	if (!shell || !shell->cmds || !shell->env)
		return ;
	if (init_pipe(&pipe_st, shell->cmds))
		return (ft_putstr_fd("Unable to initialize t_pipe pipe\n", 2));
	ft_fork(shell->cmds, &pipe_st, shell);
	if (pipe_st.prev_read_fd != -1)
		close(pipe_st.prev_read_fd);
	ft_wait(&pipe_st, shell);
}

/// @brief waits on the child processes to be finished
static void	ft_wait(t_pipe *pipe, t_shell *shell)
{
	int	i;
	int	status;
	int	sig;

	i = 0;
	while (i < pipe->pid_count)
	{
		waitpid(pipe->pids[i], &status, 0);
		if (i == pipe->pid_count - 1)
		{
			if (WIFEXITED(status))
				shell->exit_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
			{
				sig = WTERMSIG(status);
				shell->exit_status = 128 + sig;
				if (sig == SIGQUIT)
					ft_putstr_fd("Quit (core dumped)\n", 2);
				else if (sig == SIGINT)
					write(1, "\n", 1);
			}
			else
				shell->exit_status = 1;
		}
		i++;
	}
	free(pipe->pids);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_cmd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 19:29:21 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/18 21:12:43 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief cleans the t_cmd list
/// @param lst the pointer to the list
/// @param msg an error msg. NULL if not to print anything
void	ft_clean_cmd_lst(t_cmd **lst, char *msg)
{
	t_cmd	*current;

	if (!lst || !*lst)
		return ;
	while (*lst)
	{
		current = *lst;
		*lst = (*lst)->next;
		if (current->redirs)
			ft_clean_redirs(&current->redirs);
		if (current->cmd)
		{
			free(current->cmd);
			current->cmd = NULL;
		}
		if (current->args)
			ft_free_args(current->args);
		free(current);
		current = NULL;
	}
	*lst = NULL;
	if (msg)
		ft_putstr_fd(msg, 2);
}

/// @brief cleans the redirections
/// @param redirs the list of redirections for an specific t_cmd
void	ft_clean_redirs(t_redir **redirs)
{
	t_redir	*current;

	if (!redirs || !*redirs)
		return ;
	while (*redirs)
	{
		current = *redirs;
		*redirs = (*redirs)->next;
		if (current->file)
		{
			free(current->file);
			current->file = NULL;
		}
		if (current->fd != -1)
		{
			close(current->fd);
			current->fd = -1;
		}
		free(current);
		current = NULL;
	}
	*redirs = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_env.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 19:30:14 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/18 18:51:22 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_clean_env(t_env **env, char *msg)
{
	t_env	*current;

	if (!env || !*env)
		return ;
	while (*env)
	{
		current = *env;
		*env = (*env)->next;
		if (current->name)
			free(current->name);
		if (current->value)
			free(current->value);
		if (current->next)
			current->next = NULL;
		free(current);
	}
	*env = NULL;
	if (msg)
		ft_putstr_fd(msg, 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_shell.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 19:30:22 by adpinhei          #+#    #+#             */
/*   Updated: 2025/12/11 15:35:47 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief cleans the t_shell super structure
/// @param shell the reference to the t_shell structure
/// @param msg str to be printed in case of error
void	ft_clean_shell(t_shell *shell, char *msg)
{
	if (!shell)
		return ;
	if (shell->cmds)
	{
		ft_clean_cmd_lst(&shell->cmds, msg);
		shell->cmds = NULL;
	}
	if (shell->env)
	{
		ft_clean_env(&shell->env, msg);
		shell->env = NULL;
	}
	if (shell->tokens)
	{
		ft_clean_tokens(&shell->tokens, msg);
		shell->tokens = NULL;
	}
	free(shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_tokens.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/04 15:17:25 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/18 20:31:30 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief cleans the list of t_token nodes
/// @param lst the list to be cleaned
void	ft_clean_tokens(t_token **lst, char *msg)
{
	t_token	*current;
	t_token	*next;

	if (!lst || !*lst)
		return ;
	current = *lst;
	while (current)
	{
		next = current->next;
		free(current->value);
		free(current);
		current = next;
	}
	*lst = NULL;
	if (msg)
		ft_putstr_fd(msg, 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 19:31:06 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/15 20:20:45 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_free_args(char **args)
{
	int	i;

	if (!args)
		return ;
	i = 0;
	while (args[i])
	{
		free(args[i]);
		i++;
	}
	free(args);
	args = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_pipe.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adpinhei <adpinhei@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/24 15:42:22 by adpinhei          #+#    #+#             */
/*   Updated: 2025/11/24 15:42:41 by adpinhei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief closes open fd's from pipe if they're open and sets them to -1.
/// @param str to be passed to STDERR_FILENO in case of error.
void	ft_closepipe(int fd1, int fd2, char *str)
{
	if (fd1 >= 0)
	{
		close(fd1);
		fd1 = -1;
	}
	if (fd2 >= 0)
	{
		close(fd2);
		fd2 = -1;
	}
	if (str)
		ft_putstr_fd(str, 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:09:43 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 11:58:10 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	change_env(char *old_pwd, char *new_pwd, t_shell *shell)
{
	t_env	*env;

	env = shell->env;
	
	while (env)
	{
		if (ft_strncmp(env->name, "OLDPWD", 6) == 0)
		{
			free(env->value);
			env->value = ft_strdup(old_pwd);
		}
		else if (ft_strncmp(env->name, "PWD", 3) == 0)
		{
			free(env->value);
			env->value = ft_strdup(new_pwd);
		}
		env = env->next;
	}
}

char	*get_bigger_buffer(char *prev, int prev_len, int new_prev_len)
{
	char	*new_cwd;
	
	new_cwd = malloc(new_prev_len);
	if (!new_cwd)
	{
		free(prev);
		return (NULL);
	}
	ft_memcpy(new_cwd, prev, prev_len);
	free(prev);
	return (new_cwd);
}

char	*copy_from_env(char **args, t_shell *shell)
{
	t_env	*tmp;
	if (args[0] == NULL )
	{
		tmp = shell->env;
		while (tmp)
		{
			if (ft_strncmp(tmp->name, "HOME", 4) == 0)
				return(ft_strdup(tmp->value));
			tmp = tmp->next;
		}
		return (NULL);
	}
	return (ft_strdup(args[0]));
}

char	*get_current_path(void)
{
	char	*cwd;
	int	len;

	len = 1024;
	cwd = malloc(len);
	if (!cwd)
		return (NULL);
    while (getcwd(cwd, len) == NULL)
    {
        if (errno != ERANGE)
        {
            free(cwd);
            return NULL;
        }
        cwd = get_bigger_buffer(cwd, len, len * 2);
        if (!cwd)
            return NULL;
        len *= 2;
    }
	return (cwd);
}

void	ft_cd(t_shell *shell)
{
	char	**args;
	char	*pwd;
	char	*old_pwd;
	int		change_dir;
	char	*path_to_change;

	args = shell->cmds->args + 1;
	if (!args[0] || !args[0][0])
	{
		path_to_change = copy_from_env(args, shell);
		old_pwd = get_current_path();
		change_dir = chdir(path_to_change);
		free(path_to_change); 
		pwd = get_current_path();
		change_env(old_pwd, pwd, shell);
		shell->exit_status = 0;
		return ;
	}
	if (args[0] && args[1])
	{
		ft_putstr_fd("minishell: cd: too many arguments\n", 2);
		shell->exit_status = 1;
		return ;
	}
	old_pwd = get_current_path();
	change_dir = chdir(args[0]);
	if (change_dir == -1)
	{
		//perror("cd");
		shell->exit_status = 1;
		return ;
	}
	pwd = get_current_path();
	change_env(old_pwd, pwd, shell);
	shell->exit_status = 0;
	return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 17:12:42 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 13:19:02 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief check my option -n
/// @param args check if argument is a -n
/// @return positive if it is -n
static int	ft_checkflag(char *args)
{
	int	i;

	i = 0;
	if (!args || args[0] != '-')
		return (0);
	i++;
	while(args[i])
	{
		if (args[i] == 'n')
			i++;
		else
			return (0);
	}
	return (1);
}
/// @brief will print what was writen on the terminal
/// @param args the arguments from terminal
void	ft_echo(char **args, t_shell *shell)
{
	int	i;
	int	sign;

	i = 0;
	sign = 0;
	if (!args[i])
	{
		printf("\n");
		shell->exit_status = 0;
		return ;
	}
	if (ft_checkflag(args[i]))
	{
		i++;
		sign = 1;		
	}
	while (args[i])
	{
		printf("%s", args[i]);
		if (args[i + 1])
			printf(" ");
		i++;
	}
	if (sign == 0)
		printf("\n");
	shell->exit_status = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/04 17:32:06 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/04 17:32:09 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

 
/// @brief Will print all env's list
/// @param env to be printed
void	ft_env(t_env *env)
{
	while (env)
	{
		if (env->value && env->value[0])
		{
			printf("%s=", env->name);
			printf("%s", env->value);	
			printf("\n");
		}
			env = env->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/25 17:19:03 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/11 15:36:27 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

#include <limits.h>

static int	check_overflow(long long result, int sign, int digit)
{
	if (sign == 1)
	{
		if (result > LLONG_MAX / 10
			|| (result == LLONG_MAX / 10
			&& digit > LLONG_MAX % 10))
			return (1);
	}
	else
	{
		if (result > -(LLONG_MIN / 10)
			|| (result == -(LLONG_MIN / 10)
			&& digit > -(LLONG_MIN % 10)))
			return (1);
	}
	return (0);
}

int	safe_atoll(const char *str, long long *out)
{
	int			i;
	int			sign;
	long long	result;

	i = 0;
	sign = 1;
	result = 0;
	if (ft_strncmp(str, "--", ft_strlen(str)) == 0)
	{
		*out = 0;
		return (1);
	}
	while (str[i] == ' ' || (str[i] >= '\t' && str[i] <= '\r'))
		i++;
	if (str[i] == '+' || str[i] == '-')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	if (!str[i])
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9' 
			|| check_overflow(result, sign, str[i] - '0'))
			return (0);
		result = result * 10 + (str[i] - '0');
		i++;
	}
	*out = result * sign;
	return (1);
}

void	ft_exit(char **args, char *cmd, t_shell *shell)
{
	long long	val;

	if (ft_strncmp(cmd, "exit", 4) == 0)
	{
		printf("exit\n");
		if (!args[0])
		{
			ft_clean_shell(shell, NULL);
			exit(shell->exit_status);
		}
		if (!safe_atoll(args[0], &val))
		{
			ft_putstr_fd("exit: ", 2);
			ft_putstr_fd(args[0], 2);
			ft_putstr_fd(": numeric argument required\n", 2);
			ft_clean_shell(shell, NULL);
			exit(2);
		}
		if (args[1])
		{
			ft_putstr_fd("minishell: exit: too many arguments\n", 2);
			shell->exit_status = 1;
			return ;
		}
		shell->exit_status = val % 256;
		ft_clean_shell(shell, NULL);
		exit((unsigned char)val);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 15:26:29 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 12:46:30 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_env(t_env *env);

/// @brief this function will create a new node
/// @param env_str the argument that I'll use to fill env node
/// @return new node
t_env	*create_env_node(const char *env_str)
{
	t_env	*node;
	char	*equal;

	node = malloc(sizeof(t_env));
	if (!node)
		return (NULL);

	equal = strchr(env_str, '=');

	if (equal)
	{
		node->name = strndup(env_str, equal - env_str);
		node->value = strdup(equal + 1);
	}
	else
	{
		node->name = strdup(env_str);
		node->value = strdup("");
	}
	node->next = NULL;
	return (node);
}

int	check_args(char *args)
{
	int	i;
	
	i = 0;
	if (!((args[i] >= 'a' && args[i] <= 'z')
        || (args[i] >= 'A' && args[i] <= 'Z')
        || args[i] == '_'))
        return (0);
	i++;
	while (args[i] && args[i] != '=')
	{
		if (ft_isalnum(args[i]) || args[i] == '_' 
			|| (args[i] == '+' && args[i + 1] == '='))
			i++;
		else
			return (0);
	}
	return (1);
}

/// @brief find the last node of the list
/// @param lst env's list
/// @return the address of the last list's node
static t_env	*ft_envlast(t_env *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next)
		lst = lst->next;
	return (lst);
}
/// @brief adding the variable created by export to the end of env's list
/// @param lst env's list
/// @param  new the new node
static void	ft_envadd_back(t_env **lst, t_env *new)
{
	t_env	*last;

	if (!lst || !new)
		return ;
	if (*lst == NULL)
		*lst = new;
	else
	{
		last = ft_envlast(*lst);
		last->next = new;
	}
}

t_env	*get_value(t_env *env, char *name)
{
	    t_env *current = env;

    while (current)
    {
        if (strcmp(current->name, name) == 0)
			return (current);
		current = current->next;
    }
	return (NULL);
}

void set_value(char *str, t_env **env)
{
    char *equal;
    char *name;
    t_env *target;
    int is_append;

	equal = ft_strchr(str, '=');
	is_append = 0;
    if (equal && equal > str && equal[-1] == '+')
    {
        is_append = 1;
        name = ft_substr(str, 0, equal - str - 1);
    }
    else if (equal)
        name = ft_substr(str, 0, equal - str);
    else
        name = ft_strdup(str);
    target = get_value(*env, name);
    if (!target)
    {
        if (equal)
        {
            char *value = ft_strdup(equal + 1);
            t_env *new = malloc(sizeof(t_env));
            new->name = ft_strdup(name);
            new->value = value;
            new->next = NULL;
            ft_envadd_back(env, new);
        }
        else
        {
            t_env *new = malloc(sizeof(t_env));
            new->name = ft_strdup(name);
            new->value = ft_strdup("");
            new->next = NULL;
            ft_envadd_back(env, new);
        }
        free(name);
        return;
    }
    if (equal)
    {
        if (is_append)
        {
            char *new_value = ft_strjoin(target->value, equal + 1);
            free(target->value);
            target->value = new_value;
        }
        else
        {
            free(target->value);
            target->value = ft_strdup(equal + 1);
        }
    }
    free(name);
}

/// @brief replicating export's behaviours
/// @param args the arguments received from terminal
/// @param env env's list
void	ft_export(char **args, t_shell *shell)
{
	int	i;
	t_env	*env;

	i = 0;
	env = shell->env;	
	if (!args || !args[0])
	{
		while (env)
		{
			printf("declare -x ");
			printf("%s", env->name);
			if (env->value && env->value[0])
				printf("=");
			printf("\"%s\"", env->value);	
			printf("\n");
			env = env->next;
		}
		shell->exit_status = 0;
		return ;
	}
	while (args[i])
	{
		if (!check_args(args[i]))
		{
			ft_putstr_fd("export: ", 2);
			ft_putstr_fd(args[i], 2);
			ft_putstr_fd(": not a valid identifier\n", 2);
			shell->exit_status = 1;
			return ;
		}
		set_value(args[i], &shell->env);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_builtin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/14 14:19:51 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 15:14:27 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	ft_env(t_env *env);
void	ft_echo(char **args, t_shell *shell);
void	ft_export(char **args, t_shell *shell);
void	ft_pwd(t_env *env);
void	ft_unset(char **args, t_shell *shell);
void	ft_cd(t_shell *shell);
void	ft_exit(char **args, char *cmd, t_shell *shell);

void	execute_builtin(t_cmd *cmd, t_shell *shell)
{
	char **args;
	t_env	*env;

	args = cmd->args + 1;
	env = shell->env;
	if (ft_strncmp(cmd->cmd, "pwd", 4) == 0)
		ft_pwd(env);
	else if (ft_strncmp(cmd->cmd, "echo", 5) == 0)
		ft_echo(args, shell);
	else if (ft_strncmp(cmd->cmd, "env", 4) == 0)
		ft_env(env);		
	else if (ft_strncmp(cmd->cmd, "export", 7) == 0)
		ft_export(args, shell);
	else if (ft_strncmp(cmd->cmd, "unset", 6) == 0)
		ft_unset(args, shell);
	else if (ft_strncmp(cmd->cmd, "cd", 3) == 0)
	 	ft_cd(shell);
	else if (ft_strncmp(cmd->cmd, "exit", 5) == 0)
		ft_exit(args, cmd->cmd, shell);
	else
		shell->exit_status = 127;
}

int	ft_is_parent_builtin(t_cmd *cmd)
{
	if (!cmd || !cmd->cmd)
		return (1);
	if (ft_strncmp(cmd->cmd, "cd", ft_strlen(cmd->cmd)) == 0 
		|| ft_strncmp(cmd->cmd, "exit", ft_strlen(cmd->cmd)) == 0
			|| ft_strncmp(cmd->cmd, "export", ft_strlen(cmd->cmd)) == 0
				|| ft_strncmp(cmd->cmd, "unset", ft_strlen(cmd->cmd)) == 0
					|| ft_strncmp(cmd->cmd, "echo", ft_strlen(cmd->cmd)) == 0
						|| ft_strncmp(cmd->cmd, "pwd", ft_strlen(cmd->cmd)) == 0
							|| ft_strncmp(cmd->cmd, "env", ft_strlen(cmd->cmd)) == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/07 16:31:29 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 11:39:57 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/// @brief Gets PWD's content from env
/// @param env env's list
/// @return PWD's content
char *getpwd(t_env *env)
{
	while(env)
	{
		if (!ft_strncmp(env->name, "PWD", 3))
			return (ft_strdup(env->value));
		env = env->next;
	}
	return (NULL);
}
/// @brief prints PWD
/// @param env env's list
void	ft_pwd(t_env *env)
{
	char	*dir;
	
	dir = getpwd(env);
	if (dir)
	{
		printf("%s\n", dir);
		free(dir);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brmaria- <brmaria-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 17:52:15 by brmaria-          #+#    #+#             */
/*   Updated: 2025/12/10 11:22:15 by brmaria-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	remove_env(t_env **env, char *name)
{
	    t_env *current = *env;
    	t_env *prev = NULL;

    while (current)
    {
        if (strcmp(current->name, name) == 0)
        {
            if (prev == NULL)
                *env = current->next;
            else
                prev->next = current->next;

            free(current->name);
            free(current->value);
            free(current);
            return;
        }
        prev = current;
        current = current->next;
    }
}

void	ft_unset(char **args, t_shell *shell)
{
	int	i;

	i = 0;

	while (args[i])
	{
		remove_env(&shell->env, args[i]);
		i++;
	}
	shell->exit_status = 0;
}